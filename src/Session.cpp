#include "Session.h"
#include "System.h"

#include <iostream>
#include <memory>

using namespace std;

namespace gameEngine
{

Session::Session() {
	// För tilläggsnivå C kolla om användargenererad händelse är kortkommando - anropa motsvarande funktion
	nextTick = SDL_GetTicks() + sys.getTickInterval();
}

// Element-funktioner
void Session::addUIElement(shared_ptr<UIElement> e)
{
	allElements.push_back(e);
	allUIElements.push_back(e);
}

// Element-funktioner
void Session::addGameElement(shared_ptr<GameElement> e)
{
	allElements.push_back(e);
	allGameElements.push_back(e);
	if (e->isAutogenerated())
		autogeneratedGameElements.push_back(e);
}

void Session::removeUIElement(shared_ptr<UIElement> e)
{
	allElementsRemoved.push_back(e);
	allUIElementsRemoved.push_back(e);
}

void Session::removeGameElement(shared_ptr<GameElement> e) {
	allElementsRemoved.push_back(e);
	allGameElementsRemoved.push_back(e);
}

void Session::removeAllElements() {
	for (shared_ptr<Element> e : allElements) 
		allElementsRemoved.push_back(e);
}

void Session::checkUserInput() {
	SDL_Event event;

	// Kollar användargenererade händelser
	while (SDL_PollEvent(&event))
	{
		switch (event.type)
		{
		case SDL_QUIT:
			quit = true;
			break;
		case SDL_MOUSEBUTTONDOWN:
			for (shared_ptr<Element> e : allElements)
				e->mouseDown(event);
			break;
		case SDL_MOUSEBUTTONUP:
			for (shared_ptr<Element> e : allElements)
				e->mouseUp(event);
			break;
		case SDL_KEYDOWN:
			for (shared_ptr<Element> e : allElements)
				e->keyDown(event);
			break;
		case SDL_KEYUP:
			for (shared_ptr<Element> e : allElements)
				e->keyUp(event);
				break;
		}	// Switch
	}	// Inre while-loop
}

void Session::autogenerateObject() {
	//for(std::vector<shared_ptr<GameElement>>::iterator i = autogeneratedGameElements.begin(); i != autogeneratedGameElements.end();) {
	//int delayAutogenerate = (nextTick+sys.getTickInterval())- SDL_GetTicks();
	tickCount++;
		// Slumpa target
		// tickCount % tickCount + sys.getTickInterval() == 1)
		if (!(autogeneratedGameElements.empty()) && (tickCount % 753 == 1)) {
			cout << "autogenerating..." << endl;
			int i = rand() % autogeneratedGameElements.size();
			shared_ptr<GameElement> e = autogeneratedGameElements.at(i);
			int ex = e->getRect().x;
			e->setCoordinateX(ex+10);
			addGameElement(e);
		} 
}

void Session::updateObjectsState() {
	// Uppdaterar samtliga objekt
	for (shared_ptr<GameElement> e : allGameElements) {
		e->tick();
	}
			
}

void Session::checkForCollision() {
	
	// Kollisionskontroll för objekt
	for (shared_ptr<GameElement> e : allGameElements) {
		for (shared_ptr<GameElement> eOther : allGameElements)
			if (e != eOther) {
				// Omgivande rektangel med omgivande rektangel
				const SDL_Rect *eRect = &e->getRect();
				const SDL_Rect *eOtherRect = &eOther->getRect();

				if (SDL_HasIntersection(eRect, eOtherRect)) {		
					if (e->isUserControlled()) {
						eOther->collide();
						//adderar players totala points med targets points
						e->setPoints(e->getPoints()+eOther->getPoints());
						removeGameElement(eOther);
					}
					if (eOther->isUserControlled()) {
						e->collide();
						//adderar players totala points med targets points
						eOther->setPoints(eOther->getPoints()+e->getPoints());
						removeGameElement(e);
					}
					cout << "Kollision" << endl;
				}
					
			}
			//	if (eMinX < eOtherMinX && eMaxX < eOtherMaxX &&)

			//	int playerMinX = player.getRect().x; 
			//	int playerMaxX = playerMinX + player.getRect().w;
		//		int targetMiddleX = t->getRect().x + (t->getRect().w/2);

		//		int y = player.getRect().y + (player.getRect().h*0.9);
		//		int targetY = t->getRect().y + t->getRect().h;
		//		int playerY = y % 5 == 0 ? y : y - (y % 5);

	//			shared_ptr<Label> targetPoints;
				// Beräknat att en kollision kommer att ske
			/*	if (playerMinX < targetMiddleX && targetMiddleX < playerMaxX) {
					if((targetY + 10) == (playerY - 10)) {
						SDL_Rect r = t->getRect();
						int h = r.h;
						int w = r.w;
						int x = r.x;
						int y = r.y;
						t->setHeight(h-5);
						t->setWidth(w-5);
						t->setCoordinateX(x+2.5);
						t->setCoordinateY(y + 5);
					}
					else if (!(t->hasCollided()) && targetY == playerY)
					{
						
						t->setCollided(true);
						std::cout << "KOLLISION:" << "playerMinX: " << playerMinX << ", playerMaxX: " << playerMaxX << ", targetMiddleX: " << targetMiddleX << ", playerY :" << playerY << ", targetY: " << targetY << std ::endl; // Hantering av kollision görs här
						removeGameElement(t);
						score += 1000;
						scoreLbl->setText("Score: " + to_string(score));
						*/
		}
}
		

void Session::handleAddedObjects() {
	// Lägger till nya objekt
	for (shared_ptr<Element> e : allElementsAdded)
		allElements.push_back(e);
	allElementsAdded.clear();
}


void Session::handleRemovedObjects() {

	// Tar bort raderade objekt
	for (shared_ptr<Element> e : allElementsRemoved)
	{
		for (vector<shared_ptr<Element>>::iterator i = allElements.begin(); i != allElements.end();)
		{
			if (*i == e)	
				i = allElements.erase(i);
			else
				i++;
		} // Inre for-loop
	}	// Yttre for-loop	
	allElementsRemoved.clear();

	for (shared_ptr<GameElement> gme : allGameElementsRemoved) {
		for (vector<shared_ptr<GameElement>>::iterator i = allGameElements.begin(); i != allGameElements.end();)
		{
			if (*i == gme)
			{		
				i = allGameElements.erase(i);
			}
			else
				i++;
		} // Inre for-loop
	} // Yttre for-loop
	allGameElementsRemoved.clear();
}

void Session::drawObjects() {
	// Ritar ut objekten i det uppdaterade tillståndet
	SDL_RenderClear(sys.getRen());
	SDL_RenderCopy(sys.getRen(), sys.getTex(), NULL, NULL);

	for (shared_ptr<Element> e : allElements)
		e->draw();
	SDL_RenderPresent(sys.getRen());
}

void Session::handleDelay() {
	// Tid kontrolleras och fördröjning framkallas
	int delay = nextTick - SDL_GetTicks();
	if (delay > 0)
		SDL_Delay(delay);
}

	void Session::run()
	{
		while (!quit)
		{
			checkUserInput();
			//autogenerera gameelements
			autogenerateObject();
			updateObjectsState();
			checkForCollision();
			handleAddedObjects();
			handleRemovedObjects();
			drawObjects();
			handleDelay(); 
		}
	}

}